(function(a,b){if("function"==typeof define&&define.amd)define(["exports"],b);else if("undefined"!=typeof exports)b(exports);else{var c={exports:{}};b(c.exports),a.hclust=c.exports}})("undefined"==typeof globalThis?"undefined"==typeof self?this:self:globalThis,function(a){"use strict";function b(a){return e(a)||d(a)||c()}function c(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function d(a){if(Symbol.iterator in Object(a)||"[object Arguments]"===Object.prototype.toString.call(a))return Array.from(a)}function e(a){if(Array.isArray(a)){for(var b=0,c=Array(a.length);b<a.length;b++)c[b]=a[b];return c}}Object.defineProperty(a,"__esModule",{value:!0}),a.clusterData=a.maxDistance=a.minDistance=a.averageDistance=a.euclideanDistance=void 0;// get euclidean distance between two equal-dimension vectors
var f=function(c,a){for(var b=Math.min(c.length,a.length),d=0,e=0;e<b;e++)d+=(c[e]-a[e])*(c[e]-a[e]);return Math.sqrt(d)};// get average distance between sets of indexes, give distance matrix
a.euclideanDistance=f;var g=function(c,d,e){var f=0,g=!0,h=!1,i=void 0;try{for(var j,k=c[Symbol.iterator]();!(g=(j=k.next()).done);g=!0){var l=j.value,a=!0,m=!1,n=void 0;try{for(var o,p,q=d[Symbol.iterator]();!(a=(o=q.next()).done);a=!0)p=o.value,f+=e[l][p]}catch(a){m=!0,n=a}finally{try{a||null==q.return||q.return()}finally{if(m)throw n}}}}catch(a){h=!0,i=a}finally{try{g||null==k.return||k.return()}finally{if(h)throw i}}return f/c.length/d.length};// get smallest distance between sets of indexes, give distance matrix
a.averageDistance=g;a.minDistance=function minDistance(c,d,e){var f=1/0,g=!0,h=!1,i=void 0;try{for(var j,k=c[Symbol.iterator]();!(g=(j=k.next()).done);g=!0){var l=j.value,a=!0,m=!1,n=void 0;try{for(var o,p,q=d[Symbol.iterator]();!(a=(o=q.next()).done);a=!0)p=o.value,e[l][p]<f&&(f=e[l][p])}catch(a){m=!0,n=a}finally{try{a||null==q.return||q.return()}finally{if(m)throw n}}}}catch(a){h=!0,i=a}finally{try{g||null==k.return||k.return()}finally{if(h)throw i}}return f};a.maxDistance=function maxDistance(c,d,e){var f=0,g=!0,h=!1,i=void 0;try{for(var j,k=c[Symbol.iterator]();!(g=(j=k.next()).done);g=!0){var l=j.value,a=!0,m=!1,n=void 0;try{for(var o,p,q=d[Symbol.iterator]();!(a=(o=q.next()).done);a=!0)p=o.value,e[l][p]>f&&(f=e[l][p])}catch(a){m=!0,n=a}finally{try{a||null==q.return||q.return()}finally{if(m)throw n}}}}catch(a){h=!0,i=a}finally{try{g||null==k.return||k.return()}finally{if(h)throw i}}return f};// update progress by calling user onProgress and postMessage for web workers
var h=function(a,b,c){// currently only two distinct steps: computing distance matrix and clustering
var d=a/2+b/2;// if onProgress is defined and is a function, call onProgress
"function"==typeof c&&c(d),"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&postMessage(d)},i=function(a){return console.log("Clustering: ",(100*a).toFixed(1)+"%")};// default onProgress function. console logs progress
a.clusterData=function clusterData(a){var c=a.data,d=void 0===c?[]:c,e=a.key,j=void 0===e?"":e,k=a.distance,l=void 0===k?f:k,m=a.linkage,n=void 0===m?g:m,o=a.onProgress,p=void 0===o?i:o;j&&(d=d.map(function(a){return a[j]}));// iterate through data
for(var q=d.map(function(a,b){// get distance between datum and other datum
return h(0,b/(d.length-1),p),d.map(function(b){return l(a,b)})}),r=d.map(function(a,b){return{height:0,indexes:[+b]}}),s=[],t=0;t<d.length&&(h(1,(t+1)/d.length,p),s.push(r.map(function(a){return a.indexes})),!(t>=d.length-1));t++){// upper triangular matrix of clusters
for(var u=1/0,v=0,w=0,x=0;x<r.length;x++)for(var y,z=x+1;z<r.length;z++)// calculate distance between clusters
y=n(r[x].indexes,r[z].indexes,q),y<u&&(u=y,v=x,w=z);// merge nearestRow and nearestCol clusters together
var A={indexes:[].concat(b(r[v].indexes),b(r[w].indexes)),height:u,children:[r[v],r[w]]};// remove nearestRow and nearestCol clusters
// splice higher index first so it doesn't affect second splice
r.splice(Math.max(v,w),1),r.splice(Math.min(v,w),1),r.push(A)}// assemble full list of tree slices into array where index = k
// return useful information
return s=[[]].concat(b(s.reverse())),{clusters:r[0],distances:q,order:r[0].indexes,clustersGivenK:s}}});
